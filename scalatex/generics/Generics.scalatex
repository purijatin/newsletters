@import Main._
@import scalatex.site._

@import scalatex.site.Section

@a(
  href:="https://github.com/purijatin/newsletters",
  position.absolute,
  top:=0,right:=0,border:=0,
  img(
    src:="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67",
    alt:="Fork me on GitHub"
  )
)

@sect("Polymorphism")
  @p
    	Parametric Polymorphism is the ability to express data and functions over an abstract type but without specifying it. It is powerful in a sense that it lets you model behavior effectively.

  @p 
  		Different languages have chosen different tradeoffs between code footprint and abstraction to implement Parametric Polymorphism, hence giving rise to different flavors in implentation.
  		Java's type system is not as expressive as one would like it to be, but never the less has a mechanism to do Parametric Polymorphism with a construct called @code{Generics}.

  @sect{Generics}
    @p 
        Generics are called and implemented differently in different languages. Two of the well known implementations are using:

    @sect{Type Erasure} 
        @p 
            Compiler by a process called as Homogeneous Translation erases all possible reference translations of a class at compile time to one class at runtime. 
            Java compiler does this. An example:
        @hl.scala
            List<Animal> ls = new ArrayList<Animal>();
            List<String> ls = new ArrayList<String>();
        @p
            Both the above gets converted to below at runtime:
        @hl.scala
            List ls = new ArrayList();
        @p
            This technique is called as Type Erasure. Simply put, here generics are purely a compiler creation and runtime has no clue about their existence. 
            Compiler provides adequate type-safety at compile time but @code{erases} (we are going to use this word a lot) them at runtime. 
            In Java8, there is no special byte-code for Generic classes or generic methods. Its like a dream, you see it but doesnt exist in reality. 
            This also means, it is difficult to know the exact parametric type of list at runtime. (Not impossible though. See below). As a side-effect:
        @div
        @hl.highlight(
          """  public void evaluate(List<Integer> ls)
  public void evaluate(List<String> ls)
  //both the above gets compiled to the same method below (to verify do `javap -c file.class`):

  public void evaluate(List ls)
  //This is why you cannot do method-overloading based on parametric type""",
          "scala"
        )     

        @p
          Nor can you do below or do reflection:
        @div
          @hl.highlight(
            """  class Sample<T>{
    T ob = new T(); //not possible
 }""",
            "scala"
          ) 

        @p
          Never the less Type-Erasure has been a vital reason for the success of JVM (more on it below)
        @p

    @sect{Reification}

        @p
            An alternative way to implement generics is using a process called Heterogenous Translation. Languages like C++ and C#* have a provison where they create a specialized class for each instantiation of a template.
            Which means compiler not only provides type safety at compile-time but the Parametric Types are also embeded at runtime. A classic example are @code{Arrays} in Java. For example:
        @hl.ref(wd/'generics/'src/'main/'java/"Animal.java")
        @hl.ref(wd/'generics/'src/'main/'java/"Reify.java", start="Dog[]", end="//end")
        This ability to contain the type at runtime is called @code{reifiability}. In Java all primities, non-generic classes are reifiable.
        @p 
            Another example of reified types in Java are specializations to be introduced in java9 under @a("Project-Valhalla",href:="http://openjdk.java.net/projects/valhalla/")
        @hl.ref(wd/'generics/'src/'main/'resources/"Java9.java",start="ls1", end="//end")
        @p
            At runtime @code{List<int>} knows that it is a list of @code{int's}. The information is not erased. This functionality is available only for primitives and value classes (Yes! the same value classes of the functional world)
        @hr
        @p
            Generics in java were introduced in java5. They are erased for so as to be compatible with pre-java5 code. 
        @hl.scala
            public void get(List ls){}
            get(new ArrayList<Animal>()) //This would have not compiled if the types were reified as then the byte-code would have changed
        @p
            Type-Erasure has been a vital success on JVM. More so as other JVM languages like Groovy, Clojure, Scala, Kotlin have been able to do their innovation with no limitation on the runtime-side. 
            This would had certainly not been possible if they were reified. To explain further: @u{Being able to inspect types at runtime undermines the knowledge you have about types at compile time}.
            We will see more on this later.
                    
  @sect{Sub-Typing (<:)}     
    @p
      What do we mean when we say @b{Dog is a sub-type of Animal}? i.e. @code{Dog <: Animal}.
    @sect{Liskov Substitution}
      @p
        @a("Liskov Substitution Principle",href:="http://www.cs.cmu.edu/afs/cs.cmu.edu/project/venari/papers/subtype-tr/paper.ps") tells that:
        @blockquote{If "A" extends "B" (A <: B), then all the things that can be done with "B" should also be legal with "A"}
      @p 
        If Dog extends Animal, then the animal object can be legally replaceable by the dog object all through. 
      @p Some notations:
      @ul
        @li 
          Subtype @code{<:} - This can be read as @b{extends}. Example: Dog extends Animal. @code{Dog <: Animal}
        @li 
          Supertype @code{>:} - The opposite of @code{<:}. Example: Animal is a Supertype of Dog. @code{Animal >: Dog}
        @li 
          @code{=:=} - Neither Sub or Super type. If @code{A =:= B} then A is same as B  
        
      @p
        We will see the how generics behave with Sub-Typing and its influence on class design.
  @sect{Variance}
    @p
      This is as intense as it can get, but hold on. This is the one ring to rule them all in Java Generics world.
    @sect{Co-Variance}
      @p 
        Let @code{M<X>} be a class with @code{X} as its generic type. @code{M} is said to be co-variant with its generic type if:
      @hl.scala
        If A <: B, then M<A> <: M<B>
      @p 
        Arrays in Java are co-variant. 
      @hl.ref(wd/'generics/'src/'main/'resources/"Variance.java", start="Animal a", end="//end")
    @sect{Contra-Variance}
      @p 
        Let @code{M<X>} be a class with @code{X} as its generic type. @code{M} is said to be contra-variant with its generic type if:
      @hl.scala
        If A <: B, then M<A> >: M<B>
      @code{andThen} method in @a("Consumer.java",href:="https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html#andThen-java.util.function.Consumer-") is contra-variant in its argument type
      @hl.scala
        default Consumer<T> andThen(Consumer<? super T> after)
      @p 
        We will come back to this again.  
    @sect{In-Variance}  
      @p 
        Class is neither co-variance not contra-variant in its generic type. Generics (without usage of wild-card) in java are In-Variant.
      @hl.ref(wd/'generics/'src/'main/'resources/"Variance.java", start="List<Animal>", end="//end")        
      @p
        L

          
        

    	
