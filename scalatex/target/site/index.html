<html><head><link href="META-INF/resources/webjars/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" /><link href="styles.css" rel="stylesheet" /><style>
.scalatex-site-Styles-headerLink{
  color: #777;
  opacity: 0.05;
  text-decoration: none;
}


.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink{
  color: #777;
  opacity: 0.5;
  text-decoration: none;
}
.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink:hover{
  opacity: 1.0;
}
.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink:active{
  opacity: 0.75;
}

.scalatex-site-Styles-content{
  color: #777;
  line-height: 1.6em;
  margin: 0 auto;
  margin-left: auto;
  margin-right: auto;
  max-width: 800;
  padding: 0 1em;
  padding-bottom: 50px;
}
.scalatex-site-Styles-content *{
  position: relative;
}
.scalatex-site-Styles-content p{
  text-align: justify;
}
.scalatex-site-Styles-content a:link{
  color: #37a;
  text-decoration: none;
}
.scalatex-site-Styles-content a:visited{
  color: #949;
  text-decoration: none;
}
.scalatex-site-Styles-content a:hover{
  text-decoration: underline;
}
.scalatex-site-Styles-content a:active{
  color: #000;
  text-decoration: underline;
}
.scalatex-site-Styles-content code{
  color: #000;
}

/*Workaround for bug in highlight.js IDEA theme*/
span.hljs-tag, span.hljs-symbol{
    background: none;
}
    </style><script src="scripts.js"></script></head><body><div>

<a href="https://github.com/purijatin/newsletters" style="position: absolute;top: 0px;right: 0px;border: 0;"><img src="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub" /></a>


<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Polymorphism" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Polymorphism<a class=" scalatex-site-Styles-headerLink" href="#Polymorphism" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div><div class=" scalatex-site-Styles-content">

  <p>
    	Polymorphism is the ability to express the same thing in different forms (Poly=Many, Morph=Form). There are multiple flavors to polymorphism.
      One very well known flavor is in OOP with inheritance. But there are several different flavors which are quite powerful never the less.
      One of them is Parametric Polymorphism.</p>
  <p></p>
  		 To simply explain it, one can write a data type or function generically without depending upon their precise parametric (aka generic) type. And this parametric type is instantiated with particular type when needed.
       One very interesting property of this is that: All the instances of a generic function/data type behave the same irrespective of their parametric type.

  <p>
     Java gives us ability to do Parametric Polymorphism with a construct called <code>Generics</code>.
</p></div>
<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Generics" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Generics<a class=" scalatex-site-Styles-headerLink" href="#Generics" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div><div class=" scalatex-site-Styles-content">
  <p>
      Generics are named and implemented differently in different languages. Two of the well known implementations are using:
</p>
  <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="TypeErasure" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;" id="TypeErasure">Type Erasure<a class=" scalatex-site-Styles-headerLink" href="#TypeErasure" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
      <p>
          Compiler by a process called as Homogeneous Translation erases all possible reference translations of a class at compile time to one class at runtime.
          This is what Java compiler also does:</p>
      <div>
        <div style="width: 50%;float: left;">
          <pre><code class="scala scalatex-site-Styles-highlightMe">List&lt;Dog&gt; ls = new ArrayList&lt;Dog&gt;()
List&lt;Long&gt; ls = new ArrayList&lt;Long&gt;()</code></pre></div>
        <div style="width: 50%;float: left;">
          <hr /><div style="opacity: 0.6;font-style: oblique;">
             <p>
              At runtime, both the statements on left gets converted to:</p>
             <pre><code class="scala scalatex-site-Styles-highlightMe">List ls = new ArrayList();
</code></pre></div><hr /></div><div style="clear: both;"></div></div>
      <p>
          This technique is called as Type Erasure. Simply put, generics are a compile-time creation and runtime has no clue about their existence.
          Compiler provides adequate type-safety at compile time but <code>erases</code> them at runtime.</p>
      <p>
          In Java8, there is no special byte-code for Generic classes or generic methods. They dont exist in reality.
          This also means, it is difficult to know the exact generic type of list at runtime. (Not impossible though. See <a href="#CaptureType">Capture Type</a>). As a side-effect:</p>
      <div>
        <pre><code class="scala scalatex-site-Styles-highlightMe">public void evaluate(List&lt;Integer&gt; ls)
public void evaluate(List&lt;String&gt; ls)
//both the above gets compiled to the same method below (to verify do `javap -c file.class`):

public void evaluate(List ls)
//This is why you cannot do method-overloading based on generic type as they compile down to same method causing conflict</code></pre>
</div>
      <p>
        Nor can you do below:</p>
      <div>
        <pre><code class="scala scalatex-site-Styles-highlightMe"> class Sample&lt;T&gt;{
   T ob = new T(); //not possible
}</code></pre>
</div>
      <p>
        Never the less Type-Erasure has been a vital reason for the success of JVM (more on it below)</p>
      <p></p>
  <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Reification" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;" id="Reification">Reification<a class=" scalatex-site-Styles-headerLink" href="#Reification" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
      <p>
          An alternative way to implement generics is using a process called Heterogenous Translation. Languages like C++ and C# have a provision where they create a specialized class for each instantiation of a template.
          An example of this in Java, is something called <b>Specializations</b> to be introduced in java9 under <a href="http://openjdk.java.net/projects/valhalla/">Project-Valhalla</a></p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">import java.anyutil.ArrayList;
import java.anyutil.List;

/**
  * For fun build java9 yourself by following instructions here: http://openjdk.java.net/projects/valhalla/ 
  */
class Java9{
  public static void main(String[] args){	
    System.out.println(List&lt;int&gt;.class.equals(List.class));//false		
    System.out.println(List&lt;int&gt;.class.equals(List&lt;double&gt;.class));//false		
		
    System.out.println(List&lt;int&gt;.class);//interface java.anyutil.List${0=I}
    System.out.println(List&lt;double&gt;.class);//interface java.anyutil.List${0=D}		
    System.out.println(java.util.List.class);//interface java.util.List
  }
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/resources/Java9.java#L0-L16" target="_blank"><i class="fa fa-link "></i></a></pre>
      <p>
          Notice <code>List&lt;int&gt;.class</code> prints <b>java.anyutil.List${0=I</b>} and <code>java.util.List.class</code> prints <b>java.util.List</b>. This means information about Parametric Types is also embedded at runtime.
          <code>List&lt;int&gt;</code> is aware of it being a list of <code>int's</code>. The information is not erased. (Though this functionality will be available only for primitives and <a href="http://cr.openjdk.java.net/~jrose/values/values-0.html">value</a> classes in Java9. A special type variable identifier <code>any</code> is introduced for this enhanced treatment)</p>
      <p>
          This ability to contain the type information at runtime is called <code>reifiability</code>. In Java all primitives, non-generic classes are reifiable (More details in <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.7">JLS</a>). Another classic example are <code>Arrays</code> in Java. Arrays in Java are refifiable:</p>
      <div>
          <div style="width: 50%;float: left;">
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">Dog[] d = new Dog[1];
d.getClass().equals(Dog[].class);
//It knows it is an array of dogs
Object[] ob = d;
ob[0] = new Animal(); 
//throws ArrayStoreException at runtime. This is because it has information available at runtime regarding dogness of `ob`</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/Reify.java#L4-L10" target="_blank"><i class="fa fa-link "></i></a></pre></div>
          <div style="width: 50%;float: left;">
            <hr /><div style="opacity: 0.6;font-style: oblique;">
              <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">public class Animal {}
class Dog extends Animal{}
class Cat extends Animal{}

class Canine extends Dog{}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/Animal.java#L0-L5" target="_blank"><i class="fa fa-link "></i></a></pre>
</div><hr /></div><div style="clear: both;"></div></div>
      <hr />
      <p>
          Generics in java were introduced in java5. They are erased for so as to be compatible with pre-java5 code.</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">public void get(List ls){}
get(new ArrayList&lt;Animal&gt;()) //This would not have compiled if the types were reified as then the byte-code would have changed</code></pre>
      <p>
          Type-Erasure has been a vital success on JVM. More so as other JVM languages like Groovy, Clojure, Scala, Kotlin etc have been able to do their innovation with no limitation on the runtime-side.
          This would had certainly not been possible if generics were reified. To explain further: <u>Being able to inspect types at runtime undermines the knowledge you have about types at compile time</u>.
          We will see more on this later.
</p></div>
<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Sub-Typing(&lt;:)" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Sub-Typing (&lt;:)<a class=" scalatex-site-Styles-headerLink" href="#Sub-Typing(&lt;:)" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div><div class=" scalatex-site-Styles-content">
    <p>
      What do we mean when we say <b>Dog is a sub-type of Animal</b>?</p>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="LiskovSubstitution" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;" id="LiskovSubstitution">Liskov Substitution<a class=" scalatex-site-Styles-headerLink" href="#LiskovSubstitution" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
      <p>
        <a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/project/venari/papers/subtype-tr/paper.ps">Liskov Substitution Principle</a> tells that:
        <blockquote>If &quot;A&quot; extends &quot;B&quot; (A &lt;: B), then all the things that can be done with &quot;B&quot; should also be legal with &quot;A&quot;</blockquote></p>
      <p>
        An easier way to remember this is to think <code>A &lt;: B</code> as <code>A is subset of B</code>.</p>
      <p></p> Glossary of notations:
      <ul>
        <li>
          Subtype <code>&lt;:</code> - This can be read as <b>extends</b>. Example: <b>Dog extends Animal</b>. <code>Dog &lt;: Animal</code></li>
        <li>
          Supertype <code>&gt;:</code> - The opposite of <code>&lt;:</code>. Example: <b>Animal is a Supertype of Dog</b>. <code>Animal &gt;: Dog</code></li>
        <li>
          <code>=:=</code> - Neither Sub or Super type. If <code>A =:= B</code> then A and B are same
</li></ul>
      <p>
        We will now see the sub-typing of generic class and its influence on api design.</p></div>
  <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Variance" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Variance<a class=" scalatex-site-Styles-headerLink" href="#Variance" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div><div class=" scalatex-site-Styles-content">
    <p>
      This is as intense as it can get, but hold on. It is the one ring to rule them all in Generics world.</p>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Co-Variance" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;" id="Co-Variance">Co-Variance<a class=" scalatex-site-Styles-headerLink" href="#Co-Variance" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
      <p>
        Let <code>M&lt;X&gt;</code> be a class with <code>X</code> as its generic type. <code>M</code> is said to be co-variant with its generic type if:</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">If A &lt;: B, then M&lt;A&gt; &lt;: M&lt;B&gt;</code></pre>
      <p>
        Arrays in Java are co-variant.</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">Animal a = new Dog(); // Dog &lt;: Animal
Dog[] dog = new Dog[1];
Animal[] animals = dog; // Dog[] &lt;: Animal[]
Object[] objects = dog; // Dog[] &lt;: Animal[]</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/resources/Variance.java#L4-L8" target="_blank"><i class="fa fa-link "></i></a></pre>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Contra-Variance" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;" id="Contra-Variance">Contra-Variance<a class=" scalatex-site-Styles-headerLink" href="#Contra-Variance" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
      <p>
        Let <code>M&lt;X&gt;</code> be a class with <code>X</code> as its generic type. <code>M</code> is said to be contra-variant with its generic type if:</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">If A &lt;: B, then M&lt;A&gt; &gt;: M&lt;B&gt;</code></pre>
      <code>andThen</code> method in <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html#andThen-java.util.function.Consumer-">Consumer.java</a> is contra-variant in its argument type
      <pre><code class="scala scalatex-site-Styles-highlightMe">default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after)
</code></pre>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="In-Variance" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;" id="In-Variance">In-Variance<a class=" scalatex-site-Styles-headerLink" href="#In-Variance" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
      <p>
        If generic class is neither co-varianct nor contra-variant then it is invariant. Generics in Java are Invariant.</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">List&lt;Animal&gt; ls = new ArrayList&lt;Dog&gt;(); // co-variance. Invalid in Java
List&lt;Dog&gt; ls = new ArrayList&lt;Animal&gt;(); // contra-variance. Invalid in Java
List&lt;Animal&gt; ls = new ArrayList&lt;Animal&gt;(); // in-variant. valid.</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/resources/Variance.java#L12-L15" target="_blank"><i class="fa fa-link "></i></a></pre>
      <p>
        If you observe, a very interesting behavior pops up when you compare arrays and generics. <blockquote><u>Arrays are covariant and generics are invariant. Why?</u></blockquote>The rest of this post will affirm on why generics are rightly invariant and the dangers posed by arrays by being covariant.</p>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Wildcards(?)" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;" id="Wildcards(?)">Wildcards (?)<a class=" scalatex-site-Styles-headerLink" href="#Wildcards(?)" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
      <p>
        <code>?</code> is a wild card or a hack. A wild-card can be read as <b>some unknown type</b>. So when we say:</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">List&lt;?&gt; ls ;</code></pre>
      <p></p> It means `ls` is a list of some unknown type which we do not precisely know. Wild card is a bridge between pre and post Java5 code.
        <div>
        <div style="width: 50%;float: left;">
          <pre><code class="scala scalatex-site-Styles-highlightMe">List&lt;Integer&gt;  &lt;:  List&lt;?&gt;
List&lt;?&gt;  &lt;: List
// Hence by transitivity,
List&lt;Integer&gt; &lt;: List</code></pre></div>
        <div style="width: 50%;float: left;">
          <hr /><div style="opacity: 0.6;font-style: oblique;">
            <pre><code class="scala scalatex-site-Styles-highlightMe">List&lt;?&gt; ls = new ArrayList&lt;Integer&gt;();
List ls2 = ls;
// Hence by transitivity,
List ls3 = new ArrayList&lt;Integer&gt;();</code></pre></div><hr /></div><div style="clear: both;"></div></div>
      <p>
        This sub-typing relationship made post java-5 code backward compatible. Wild cards are only possible in a language where generics are implemented using erasure. List&lt;?&gt; would make not make much sense in reifiable world (C++ does have template methods, so it retains behavioral parametricity but not data parametricity).</p>
      <p>
        Java's type system does not give a provison to have co-variant and contra-variant generic classess. But willd card's let you provide bounds, thus enabling co-variance and contra-variance <i>like</i> behavior in Java (Frankly the experience is far from right).
        In Java, every type variable declared as a type parameter has a bound. If no bound is declared for a type variable, <code>Object</code> is assumed.
        Wildcards are useful in situations where only partial knowledge about the type parameter is required. This property combined with bounds can be very useful:</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">List&lt;?&gt; ls ;// ls is a list of some unknown type. 
List&lt;? extends Dog&gt; dog; // dog is a list of elements of some unknown type.
// In java, all reference types extends Object. So now we know that:
//	-	This unknown type &lt;: Object
//	-	Thus unknown type &lt;: Dog
// What we do not know is, the precise type of the unknown type. It can be anything in between the bounds
List&lt;? super Dog&gt; dog; 		
//	 Dog &lt;: This unknown type &lt;: Object</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/resources/Variance.java#L19-L27" target="_blank"><i class="fa fa-link "></i></a></pre>
      <p>
        In Java, co-variance and contra-variance of generics is not possible first-hand. But using bounds with wildcards, you can replicate the behavior as a second class citizen.</p>
      <div style="opacity: 0.5;font-style: oblique;">
        <p>
          For people interested in theory behind wildcards: Wildcards are a restricted form of existential types (Remember <a href="http://en.wikipedia.org/wiki/Existential_quantification">Existential Quantifier</a> in Mathematics).
          So say if you have `SomeClass&lt;X extends String&gt;`, then `SomeClass&lt;?&gt;` is a shorthand for`SomeClass&lt;T&gt; forSome{type T &lt;: String}`.</p></div></div>
  <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Case-Studies" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Case-Studies<a class=" scalatex-site-Styles-headerLink" href="#Case-Studies" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div><div class=" scalatex-site-Styles-content">
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Co-VariantArrays" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;" id="Co-VariantArrays">Co-Variant Arrays<a class=" scalatex-site-Styles-headerLink" href="#Co-VariantArrays" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
      <p>
        We saw at <a href="#Co-Variance">Co-Variance</a> example, that arrays in java are co-variant:</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">public void arrays(){
	Dog[] dogs = new Dog[3];
	Animal[] ob = dogs; //because of array covariance. line-a
	ob[0] = new Cat(); //(1)
	ob[1] = &quot;&quot;;//(2)
	ob[2] = SimpleBeanFactoryAwareAspectInstanceFactory
			.getContextBean()
			.getBeanContextServiceProviderBeanInfo();//(3)
	//Thats how folks in java world name classes right?</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/resources/Variance.java#L29-L38" target="_blank"><i class="fa fa-link "></i></a></pre>
      <p>
        Line (1),(2),(3) would throw a ArrayStoreException at runtime. Why? because if it doesn't, then this will:</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">Dog d = dogs[1];
//dogs[1] is a String
//BOOM! ClassCastException</code></pre>
      <p>
        <u>Shouldn't the compiler have caught this wrong doing (i.e. Line(1),(2),(3))) at compile time?</u>.
        The culprit is making arrays as <code>co-variant</code>. i.e. the ability to do <code>Animal[] ob = dogs</code> at line-a has put us in trouble.
</p>
      <p>
        Co-Variant Arrays is language blunder. In one of the talks, Martin Odersky (creator of javac for java5) had mentioned that co-variance of arrays decision was made as a tradeoff to be able to do below in initial java version:</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">public static void sort(Object[] a) //Arrays.sort</code></pre>
      <p>
        Without arrays being co-variant it would had been impossible to have a method like sort, which could take any kind of arrays(Remember there was no generics then, so the only way to be able to take all kinds of array as argument was to make them co-variant). Obviously many modern languages have marked Arrays as invariant and use generics to exhibit parametric polymorphism. (i.e. <code>String[]</code> becomes <code>Array&lt;String&gt;</code>)</p>
      <p>
        Co-Variant Arrays are also a reason why arrays of generic classes are illegal:</p>
      <div>
        <div style="width: 50%;float: left;">
          <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">ArrayList&lt;String&gt;[] ls = 
	new ArrayList&lt;String&gt;[3];
//Above is illegal in Java.</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/resources/Variance.java#L42-L45" target="_blank"><i class="fa fa-link "></i></a></pre></div>
        <div style="width: 50%;float: left;">
          <hr /><div style="opacity: 0.6;font-style: oblique;">
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">//If it was allowed, you could do:
Object[] ob = ls;
ob[0] = new ArrayList&lt;Animal&gt;();
//An ArrayStoreExcepton should have been thrown,
//but the runtime can't detect it
ArrayList&lt;String&gt; s = ls[0];
String name = s.get(0); 
//BOOM! BOOM! ClassCastException
//s.get(0) will return an Animal and not String		</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/resources/Variance.java#L46-L55" target="_blank"><i class="fa fa-link "></i></a></pre></div><hr /></div><div style="clear: both;"></div></div>
      <p>
        Hence the compiler does not let you create arrays of generic classes. Though there is an exception:
        <pre><code class="scala scalatex-site-Styles-highlightMe">ArrayList&lt;?&gt;[] ls = new ArrayList&lt;?&gt;[0];</code></pre>
        <p>
          The explanation on why its legal is left as food for thought to readers.
</p></p>
      <p>
        An important insight we get from above experience is: <b>Co-variance might not go well with mutability</b></p>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Writes&amp;Reads" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;" id="Writes&amp;Reads">Writes &amp; Reads<a class=" scalatex-site-Styles-headerLink" href="#Writes&amp;Reads" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
      <h1 id="Writes" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Writes" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Writes</h1>
        <p>
          Lets look at some examples. <b>All the commented ones represent a compiler error</b>:</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">public void contravariant(){
    List&lt;? super Animal&gt; ls1 = new ArrayList&lt;Animal&gt;();
    ls1.add(new Animal());
    ls1.add(new Dog());
    //ls1.add(new Object());</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/Writes.java#L4-L9" target="_blank"><i class="fa fa-link "></i></a></pre>
        <p>
          <code>ls1</code> is a list of some unknown type. This unknown type is a super type of <code>Animal</code>. When we try adding elements to
          this list, the <code>add</code> method becomes:</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">public void add((? super Animal) elem)</code></pre>
        <p>
          So now you can pass any element of a type say <code>t</code> to <code>add</code> such that, <code>t &lt;: (? super Animal)</code>. And:</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">Animal &lt;: (? super Animal)
Dog &lt;: (? super Animal)
//Object is not a super type of (? extends Animal). Hence ls1.add(new Object()) gives error</code></pre>
        <p>
          Some more examples:</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">List&lt;? super Dog&gt; ls2 = new ArrayList&lt;Dog&gt;();
//ls2.add(new Animal()); Animal does not &lt;: (? super Dog)
ls2.add(new Dog());
//ls2.add(new Object()); Object does not &lt;: (? super Dog)

List&lt;? super Object&gt; ls3 = new ArrayList&lt;Object&gt;();
ls3.add(new Animal()); // Animal &lt;: (? super Animal)
ls3.add(new Dog());
ls3.add(new Object());</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/Writes.java#L11-L20" target="_blank"><i class="fa fa-link "></i></a></pre>
        <hr />
        <p>
          Some examples with covariant variables</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">public void covariant(){
    List&lt;? extends Animal&gt; lls1 = new ArrayList&lt;Animal&gt;();
    //lls1.add(new Animal());
    //lls1.add(new Dog());
    //lls1.add(new Object());</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/Writes.java#L23-L28" target="_blank"><i class="fa fa-link "></i></a></pre>
        <p>
          <code>ls1</code> is a list of some unknown type. This unknown type is a sub type of <code>Animal</code>. When we try adding elements to
          this list, the <code>add</code> method becomes:</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">public void add((? extends Animal) elem)</code></pre>
        <p>
          So now you can pass any element of a type say <code>t</code> to <code>add</code> such that, <code>t &lt;: (? extends Animal)</code>. When we say <code>? extends Animal</code>,
          we mean some unknown type which is a subtype of Animal. Unless we do not know this unknown type, it is impossible to find <code>t</code> which is subtype of this unknown type.
          Hence the compiler gives error for <code>ls1.add(new Dog())</code> and so. Some more brain teasers:</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">List&lt;? extends Dog&gt; lls2 = new ArrayList&lt;Dog&gt;();
//lls2.add(new Animal()); Animal does not &lt;: (? extends Dog)
//lls2.add(new Dog());
//lls2.add(new Object()); Object does not &lt;: (? extends Dog)

List&lt;? extends Object&gt; lls3 = new ArrayList&lt;Object&gt;();
//lls3.add(new Animal()); // Animal &lt;: (? extends Animal)
//lls3.add(new Dog());
//lls3.add(new Object());</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/Writes.java#L30-L39" target="_blank"><i class="fa fa-link "></i></a></pre>
        <p>
          After all the above examples, it is apparent that:</p>
        <blockquote><u>Contra-Variance are great when it comes to consuming something. Co-variance is horrible in those cases</u></blockquote>
      <h1 id="Reads" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Reads" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Reads</h1>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">public void covariant(){
    List&lt;? extends Animal&gt; ls1 = new ArrayList&lt;Animal&gt;();
    Animal animal = ls1.get(0);
    Object ob = ls1.get(0);
    //Dog dog = ls1.get(0);</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/Reads.java#L4-L9" target="_blank"><i class="fa fa-link "></i></a></pre>
        <p>
          <code>ls1</code> is a list of some unknown type. This unknown type extends <code>Animal</code>. When we try to do <code>ls1.get(0)</code>, it returns a variable of type <code>? extends Animal</code>.
          So the refernce type of the variable which gets it has to be:</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">(? extends Animal) &lt;: The type t of reference variable</code></pre>
        <p>
            This means all types equal to <code>Animal</code> and above are suitable to get it. Hence it workds for <code>Animal</code> &amp; <code>Object</code> but not <code>Dog</code>. Some other similar cases:</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">List&lt;? extends Dog&gt; ls2 = new ArrayList&lt;Dog&gt;();
Dog dog1 = ls2.get(0);
Animal animal1 = ls2.get(0);
Object ob1 = ls2.get(0);

List&lt;? extends Object&gt; ls3 = new ArrayList&lt;Object&gt;();
//Dog dog2 = ls3.get(0);
//Animal animal2 = ls3.get(0);
Object ob2 = ls3.get(0);</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/Reads.java#L11-L20" target="_blank"><i class="fa fa-link "></i></a></pre>
        <hr />
        <p>
          Examples with <code>? super</code></p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">public void contravariance(){
    List&lt;? super Animal&gt; lls1 = new ArrayList&lt;Animal&gt;();
    //Animal animal = lls1.get(0);
    Object ob = lls1.get(0);
    //Dog dog = lls1.get(0);</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/Reads.java#L23-L28" target="_blank"><i class="fa fa-link "></i></a></pre>
        <p>
          When we do <code>lls1.get(0)</code>, it returns variable of unknown type which is also a super type of <code>Animal</code>. So the reference type
          which points to this variable has to be of type <code>t</code> such that</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">(? super Animal) &lt;: t</code></pre>
        <p>
          Only one such <code>t</code> can exist, and that is <code>Object</code> class. Hence it gives errors at other lines. More cases:</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">List&lt;? super Dog&gt; lls2 = new ArrayList&lt;Dog&gt;();
//Dog dog1 = lls2.get(0);
//Animal animal1 = lls2.get(0);
Object ob1 = lls2.get(0);

List&lt;? super Object&gt; lls3 = new ArrayList&lt;Object&gt;();
//Dog dog2 = lls3.get(0);
//Animal animal2 = lls3.get(0);
Object ob2 = lls3.get(0);</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/Reads.java#L30-L39" target="_blank"><i class="fa fa-link "></i></a></pre>
        <p>
          Another interesting insight from above:</p>
        <blockquote><u>Co-variance are greate when it comes to producing/reads. Contra-Variance is horrible in those case</u></blockquote>
        <hr />
        <p>
          Summing above experiences:</p>
        <blockquote><u><b>Co-Variance is great for producing/reads. Contra-Variance is great for consuming/writes</b></u></blockquote>
        <hr />
        <p>
          Some more brain teasers:</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">List&lt;? super Dog&gt; ls4 = new ArrayList&lt;Animal&gt;();//legal
ls4.add(new Dog());
ls4.add(new Canine());
//ls4.add(new Animal());

//List&lt;? super Animal&gt; ls5 = new ArrayList&lt;Dog&gt;(); //error
//List&lt;? extends Dog&gt; ls4 = new ArrayList&lt;Animal&gt;();//error

List&lt;? extends Animal&gt; ls5 = new ArrayList&lt;Dog&gt;();
//ls5.add(new Animal()); How can `t` be subtype of (? extends Animal)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/Writes.java#L44-L54" target="_blank"><i class="fa fa-link "></i></a></pre>

    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="LibraryExamples" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;" id="LibraryExamples">Library Examples<a class=" scalatex-site-Styles-headerLink" href="#LibraryExamples" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
      <p>
        After knowing the stregths and weeknesses of covariance and contravariance, lets see their impact on class design in several classes in JDK</p>
      <h1 id="ArrayList" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#ArrayList" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>ArrayList</h1>
        <h2 id="foreach" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#foreach" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>foreach</h2>
          <p>
            If we were to design <code>foreach</code> method in class <code>ArrayList&lt;T&gt;</code>, how would it be? <code>foreach</code> is like a side-effect, you pass the element of the list iteratively to extenal consumer.
            The first simplest option would be to:</p>
          <pre><code class="scala scalatex-site-Styles-highlightMe">public void forEach(Consumer&lt;T&gt; action)</code></pre>
          <p>
            This does the job, but it levies an unnecessary constraint on generic type of <code>Consumer</code> to be as same type <code>T</code> of List.
            What if we wanted to do this:</p>
          <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">ArrayList&lt;Animal&gt; fe = new ArrayList&lt;&gt;();
fe.forEach((Object o) -&gt; System.out.println(o));</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/Lib.java#L15-L17" target="_blank"><i class="fa fa-link "></i></a></pre>
          <p>
            This would throw error with our definition of <code>foreach</code>. And it shouldn't. So lets improvize. Let <code>Consumer</code> argument be of type variable <code>E</code>.
            Because we know consumer will be consuming elements, the type <code>E</code> has to:</p>
          <pre><code class="scala scalatex-site-Styles-highlightMe">E &gt;: T
// This means
? super T //Hence we get:
public void forEach(Consumer&lt;? super T&gt; consumer)</code></pre>
          <p>
            This is also how JDK defines it in <a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/3cbb65d9af9e/src/share/classes/java/util/ArrayList.java#l1225">ArrayList.foreach</a>.
            Notice again how nicely contra-variance fits in when we have to consume something. Other similar examples where we consume elements:</p>
          <pre><code class="scala scalatex-site-Styles-highlightMe">public boolean removeIf(Predicate&lt;? super E&gt; filter)
public void sort(Comparator&lt;? super E&gt; c)</code></pre>
        <h2 id="addAll" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#addAll" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>addAll</h2>
          If we were to design <code>addAll</code> method in class <code>ArrayList&lt;T&gt;</code>, the simplest solution would be to:
          <pre><code class="scala scalatex-site-Styles-highlightMe">public boolean addAll(Collection&lt;T&gt; c)</code></pre>
          <p>
            This again is too restrictive. What if you wanted to do:</p>
          <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">public void addAll(){
    ArrayList&lt;Animal&gt; addA = new ArrayList&lt;&gt;();
    ArrayList&lt;Dog&gt; b = new ArrayList&lt;&gt;();
    addA.addAll(b);
    //fine to add dogs to a list of animals</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/Lib.java#L20-L25" target="_blank"><i class="fa fa-link "></i></a></pre>
          <p>
            This would give a compiler error with our definition of <code>addAll</code>. We can improve this. With addAll we want to be able to take any collection of a type <code>E</code> such that:</p>
          <pre><code class="scala scalatex-site-Styles-highlightMe">E &lt;: T
//Hence
public &lt;E extends T&gt; boolean addAll(Collection&lt;E&gt; c)</code></pre>
          <p>
            This is also how <a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/3cbb65d9af9e/src/share/classes/java/util/ArrayList.java#l561">jdk</a> defines it (Instead of type variable, they use bound).
            Notice we will be reading from collection and how nicely covariance fits in.
</p>
      <h1 id="Collections.min" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Collections.min" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Collections.min</h1>
        <p>
          Lets try defining <code>Collections.min</code>. This method should:</p>
        <ul>
          <li>
            Take a collection as argument</li>
          <li>
            The type of collection should extend Comparable (So that we can compare them)</li>
          <li>
            Return the minumum element in collection based on Comparable.</li></ul>
        <p>
          The simplest way to do it would be by:</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">public static &lt;T extends Comparator&lt;T&gt;&gt; T min1(Collection&lt;T&gt; elem)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/Lib.java#L40-L41" target="_blank"><i class="fa fa-link "></i></a></pre>
        <p>
          From our experience, we know it is restrictive. Lets improve it. We know, we will be:</p>
        <ul>
          <li>
            Reading from the collection. Covariance fits in well here.</li>
          <li>
            Comparator will be consuming it. Contra-Variance fits well here</li></ul>
        <p>
          So what we get is this:</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">static &lt;T extends Comparator&lt;? super T&gt;&gt; T min2(Collection&lt;? extends T&gt; elem)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/Lib.java#L46-L47" target="_blank"><i class="fa fa-link "></i></a></pre>
        <p>
          Saw how simple it was? It looks scary but understanding covariance and contravariance helped us. JDK defines the method as:</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T
                                        min(Collection&lt;? extends T&gt; coll)</code></pre>
        <p>
          They also do <code>T extends Object</code>. This is required for backward compatibility purpose. In Pre-Java5 era, <code>min</code> would take a collection of <code>Object's</code>
          and return an <code>Object</code>. In our definition of min, it would return a <code>Comparable</code> and not <code>Object</code>. Putting a dummy <code>T extends Object</code> tricks the compiler to be able to return an <code>Object</code>. <a href="http://www.angelikalanger.com/GenericsFAQ/FAQSections/ProgrammingIdioms.html#FAQ104">This</a> is a good read on it.</p>
      <h1 id="Collections.copy" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Collections.copy" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Collections.copy</h1>
        <p>
          Lets try implemention a copy function that will copy elements from a list to another. We will be reading from a list and writing in another:</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">static &lt;T, E extends T&gt; void copy(List&lt;T&gt; dest, List&lt;E&gt; src)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/Lib.java#L54-L55" target="_blank"><i class="fa fa-link "></i></a></pre>
        <p>
          This does the job. There is also an alternative way. We know that we will be:</p>
        <ul>
          <li>
            Reading from src. Co-Variance will fit well.</li>
          <li>
            Write in dest. Contra-Variance will fit well.
</li></ul>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">static &lt;T&gt; void copy2(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src){</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/Lib.java#L60-L61" target="_blank"><i class="fa fa-link "></i></a></pre>
        <p>
          This will also do the job. Some more similar interesting scenarios:</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">&lt;T&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key)
&lt;T&gt; void fill(List&lt;? super T&gt; list, T obj)
&lt;T&gt; List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)
&lt;T&gt; T max(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp)
</code></pre>
      <h1 id="Object.getClass" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Object.getClass" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Object.getClass</h1>
        <p>
          A tricky one. <a href="http://hg.openjdk.java.net/jdk7/jdk7/jdk/file/tip/src/share/classes/java/lang/Object.java#l64">Object.getClass</a> is defined as:</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">public final native Class&lt;?&gt; getClass();</code></pre>
        <p>
          But in reality, the compiler returns <code>Class&lt;? extends |X|&gt;</code> where |X| is the erasure of the reference class on which <code>getClass</code> is called. For example:</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">Dog a = new Dog();
Class&lt;? extends Dog&gt; aa = a.getClass();
Animal b = a;
Class&lt;? extends Animal&gt; bb = b.getClass();</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/Lib.java#L68-L72" target="_blank"><i class="fa fa-link "></i></a></pre>
        <p>
          Compiler is doing some extra magic here. The question is: Why does it return <code>Class&lt;? extends |X|&gt;</code> rather than <code>Class&lt;|X|&gt;</code>? i.e. why doesnt it do:</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">Class&lt;Dog&gt; aa = a.getClass();
Class&lt;Animal&gt; bb = b.getClass();</code></pre>
        <p>
          The above should not be allowed. Because if it did, then <code>b.getClass</code> would return <code>Class&lt;Animal&gt;</code>. But in reality,
          the object <code>b</code> is a <code>Dog</code>. Which means <code>Class&lt;Dog&gt;</code> is the actual class object returned when we do <code>b.getClass</code>.
          And <code>Class&lt;Animal&gt; != Class&lt;Dog&gt;</code>. Hence <code>Class&lt;? extends |X|&gt;</code> is a safer bet. (Covariance again as reads).</p>
        <p>
          A similar scenario can be found with <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#asSubclass(java.lang.Class)">Class.asSubClass</a></p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">&lt;U&gt; Class&lt;? extends U&gt; asSubclass(Class&lt;U&gt; clazz)
</code></pre>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Function" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;" id="Function">Function<a class=" scalatex-site-Styles-headerLink" href="#Function" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
      <p>
        In all our cases till now, we have been dealing with classes with only one parametric type. Rules and behavior do not change will increasing rank in parametricity.</p>
      <p>
        A Function like in true mathematical sense, takes an input and returns an output (Ideally with no <a href="http://en.wikipedia.org/wiki/Side_effect_%28computer_science%29">side-effects</a>). An example:</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">Function&lt;Integer, String&gt; f = (Integer i) -&gt; String.valueOf(i);
//`f` is a function from `Integer =&gt; String`</code></pre>
      We can do transformations with functions:
      <pre><code class="scala scalatex-site-Styles-highlightMe">Let f = Integer =&gt; String
Let g = String =&gt; String

Then f o g = Integer =&gt; Integer
     g o f = String  =&gt; String</code></pre>
      <p>
        Lets try building this transformation. The simplest solution would be to:</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">public static &lt;A,B,C&gt; Function&lt;A,C&gt; andThen(Function&lt;A,B&gt; first,
                                            Function&lt;B,C&gt; later){
    return first.andThen(later);
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/Lib.java#L77-L81" target="_blank"><i class="fa fa-link "></i></a></pre>
      <p>
        This isn't a great solution. Because:</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">private static void andThenFail(){
    Function&lt;Animal, Dog&gt; f = (Animal a) -&gt; new Dog(); //Animal =&gt; Dog
    Function&lt;Object, Animal&gt; g = (Object a) -&gt; new Animal();//Object =&gt; Animal
    //Their composition should give: Animal =&gt; Animal. But
    //Function1.andThen(f,g); error
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/Lib.java#L83-L89" target="_blank"><i class="fa fa-link "></i></a></pre>
      <p>
        So we need to do better. Lets analyze it. For the composition <code>f o g</code>:</p>
      <ul>
        <li>
          We will be writing an argument to `f`. So Contra-Variance</li>
        <li>
          `f` will then return the value. Read hence Co-Variance</li>
        <li>
          The returned value by `f` will be written to `g`. Again Contra-Variance</li>
        <li>
          `g` will return the final value. Co-Variance</li></ul>
      <p>
        Hence we get:</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">public static  &lt;A,B,C&gt; Function&lt;A,C&gt; andThen2
                                    (Function&lt;? super A,? extends B&gt; first,
                                    Function&lt;? super B,? extends C&gt; later){
    return (A t) -&gt; later.apply(first.apply(t));
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/Lib.java#L91-L96" target="_blank"><i class="fa fa-link "></i></a></pre>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">public void fog(){
    Function&lt;Animal, Dog&gt; f = (Animal a) -&gt; new Dog();
    Function&lt;Object, Animal&gt; g = (Object a) -&gt; new Animal();
    Function&lt;? super Animal, ? extends Animal&gt; function = andThen2(f, g);
    Animal apply = function.apply(new Animal());
    Function&lt;Animal, Dog&gt; h = (Animal a) -&gt; new Dog();
    andThen2(andThen2(f,g), h);
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/Lib.java#L98-L106" target="_blank"><i class="fa fa-link "></i></a></pre>
      <p>
        <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html#andThen-java.util.function.Function-">andThen</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html#compose-java.util.function.Function-">compose</a> of <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html">Function.java</a> are built on the same principles.





</p></div>
  <hr>
  <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="MoreInterestingStuff" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">More Interesting Stuff<a class=" scalatex-site-Styles-headerLink" href="#MoreInterestingStuff" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div><div class=" scalatex-site-Styles-content">
    <p>
      Mind You! Some super awesome stuff on the way!</p>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="CaptureType" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;" id="CaptureType">Capture Type<a class=" scalatex-site-Styles-headerLink" href="#CaptureType" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
      <p>
        Is it possible to obtain <u>information about generic types at runtime?</u>. Well it is possible, but its dirty:
</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">class Outer{
  //Aim is to capture the type of generic type below. i.e. String
  List&lt;String&gt; ls = new ArrayList&lt;String&gt;();
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/GetType.java#L3-L7" target="_blank"><i class="fa fa-link "></i></a></pre>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">Field field = Outer.class.getDeclaredField(&quot;ls&quot;);
ParameterizedType p = (ParameterizedType) field.getGenericType();
Class&lt;?&gt; claz = (Class&lt;?&gt;)p.getActualTypeArguments()[0];
System.out.println(claz);
// prints class java.lang.String</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/GetType.java#L12-L17" target="_blank"><i class="fa fa-link "></i></a></pre>

      <p>
        Once you have <code>claz</code> variable, you can then create its instances. Lets go a step ahead...</p>
      <p>
        Low lets try building a class which will make it very easy to access parametric type information. I have called the class <a href="https://gist.github.com/purijatin/a0486995c7df0e56b398">CaptureType</a> and it lets you <u>capture the generic type of a parametrized class</u>.
        Some use cases:</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">static class Example&lt;S&gt; extends CaptureType&lt;S&gt; {}
static class SubClass extends Example&lt;Integer&gt; {}

static void test6() {
    SubClass test6 = new SubClass();
    Class&lt;?&gt; type = (Class&lt;?&gt;)test6.getTypeParam();
    equals(type, Integer.class);
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/types/UseCases.java#L49-L57" target="_blank"><i class="fa fa-link "></i></a></pre>
      <p>
        So now we are able to get Integer.class object at runtime. Some more bazooka stuff:</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">class X&lt;T&gt; extends CaptureType&lt;T&gt; {}
class Y&lt;A, B&gt; extends X&lt;B&gt; {}
class Z&lt;Q&gt; extends Y&lt;Q, Map&lt;Integer, List&lt;List&lt;List&lt;Integer&gt;&gt;&gt;&gt;&gt; {}

void test7() {
    Z&lt;String&gt; z = new Z&lt;&gt;();
    TypeADT param = z.getParamADT();
    equals(param.getRawType(), Map.class);
    List&lt;TypeADT&gt; parameters = param.getParameters();
    equals(parameters.get(0).getRawType(), Integer.class);
    equals(parameters.get(1).getRawType(), List.class);
    equals(parameters.get(1).getParameters().get(0).getRawType(), List.class);
    equals(parameters.get(1).getParameters().get(0).getParameters().get(0).getRawType(), List.class);
    equals(parameters.get(1).getParameters().get(0).getParameters().get(0).getParameters().get(0).getRawType(), Integer.class);
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/types/UseCases.java#L60-L75" target="_blank"><i class="fa fa-link "></i></a></pre>
      <p>
        Works! This is what <a href="http://mockito.org/">mockito</a> exactly does (In fact <code>CaptureType</code> was inspired from mockito).
        Though there are some limitations:</p>
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">class Sample&lt;T&gt; extends CaptureType&lt;T&gt; {}

Sample&lt;String&gt; sample = new Sample&lt;String&gt;();
sample.getRawType(); //Will throw exception
//In this case, you Field.getGenericType() to optaing parametric type information</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/resources/Wontwork.java#L0-L6" target="_blank"><i class="fa fa-link "></i></a></pre>
      <p>
        Please look at the <a href="https://gist.github.com/purijatin/a0486995c7df0e56b398">source</a> to know more. You might also want to look at <a href="https://github.com/jhalterman/typetools">TypeTools</a> which is a library to resolve generic type information declared on a class, method or even lambda.
        But they use similar techniques as above to obtain the information.</p>
      <hr />
      <h1 id="NewInstance" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#NewInstance" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>New Instance</h1>
        <p>
          Most of the time, you dont have to go this far to obtain parametric type information. And in cases where you are interested, there is an easy way out:</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">class KnowType&lt;T&gt;{
	private final Class&lt;T&gt; claz;
	public KnowType(Class&lt;T&gt; claz){
		this.claz = claz;
	}

	public Class&lt;T&gt; getTypeInfo(){
		return claz;
	}
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/types/KnowType.java#L0-L10" target="_blank"><i class="fa fa-link "></i></a></pre>
        <pre><code class="scala scalatex-site-Styles-highlightMe">KnowType&lt;Animal&gt; a = new KnowType&lt;Animal&gt;(Animal.class);
Animal a = a.getTypeInfo().newInstance();</code></pre>
        <p>
          <code>Class&lt;T&gt;</code> preserves the information. Please refer <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Class.html">Class</a> api for creating instances with constructors and much more.
          In case of generic arrays, you can:</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">class KnowArray&lt;T&gt;{
    T[] arr;
    KnowArray(Class&lt;T&gt; claz){
        this.arr = (T[]) java.lang.reflect.Array.newInstance(claz,10);
    }
    public T[] getArr(){
        return arr;
    }
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/java/types/KnowType.java#L11-L20" target="_blank"><i class="fa fa-link "></i></a></pre>

    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="JavaType-System" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;" id="JavaType-System">Java Type-System<a class=" scalatex-site-Styles-headerLink" href="#JavaType-System" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
      <p>
        Some more general details on Java and JVM's type system capabilities. Java is Nominally Typed.</p>
      <h1 id="NominalTyping" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#NominalTyping" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Nominal Typing</h1>
        <p>
          What it means is:</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">class City{
    public String getName(){}
}

class Country{
    public String getName(){}
}

static void storeInDb(City city){}
City city;
Country country;
storeInDb(country); // compiler error</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/resources/TypeSys.java#L0-L12" target="_blank"><i class="fa fa-link "></i></a></pre>
        <p>
          Even though <code>city</code> and <code>country</code> are exactly the same in construct and meaning, you cannot pass
          country to <code>storeInDb</code>. This is because the method argument is nominal to take only City. Basically,
          class names inside objects are part of what it means to be an object. Class name information inside an object is called its nominal information.
          To emphasize the fact that objects in class-based OOP have class names as part of their meaning they are sometimes called nominal objects.
</p>
        <p>
          Some programming languages instead take arguments not based on nominal type but rather based on structure of the data type. ML and Haskell are structurally typed. Scala has a some flavors of it:</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="java scalatex-site-Styles-highlightMe">def foo(x: { def getName: String }) = println(x.getName)

foo(new City) //work
foo(new Country) //works</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/purijatin/newsletters/tree/master/scalatex/generics/src/main/resources/TypeSys.java#L14-L18" target="_blank"><i class="fa fa-link "></i></a></pre>
        <p>
          Here <code>foo</code> can take any argument which has a method <code>getName</code> in it. Its based on structure rather than the name of the type.
          If you think even java8 has some small flavors of it in lambda. For example:</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">Comparator&lt;Integer&gt; a1 = (x, y) -&gt; Integer.compare(x, y);
BiFunction&lt;Integer, Integer, Integer&gt; a2 = (x, y) -&gt; Integer.compare(x, y);
BinaryOperator&lt;Integer&gt; a3 = (x, y) -&gt; Integer.compare(x, y);</code></pre>
        <p>
          You can assign any Functional Interface based on the structure of lambda. The evolution and design of lambdas is quite interesting,
          especially after the influence of Type-Erasure. <a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html">This</a> is a very very good read.
</p>
      <h1 id="Static&amp;Strong" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Static&amp;Strong" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Static &amp; Strong</h1>
        <p>
          Java is statically typed. Which means the compiler does not let you do:</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">Animal a = &quot;123&quot;;</code></pre>
        <p>
          Statically typed means that the compiler wont let you assign data/construct with a type which does not define it. Java is Strongly Typed.
          This means even at runtime you cannot wrongly assign a type to something it is not:</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">Integer i = 23;
String s = (String) i;
//ClassCastException. It knows at runtime that it an Int and not a String.</code></pre>
        <h2 id="TypeInference" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#TypeInference" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Type Inference</h2>
          <p>
            Type Inference refers to the abiliy to deduce the type of a datatype or an expression automatically. Java Compiler
            leverages its type inference power to deduce type automatically. Some simple examples would be:</p>
          <pre><code class="scala scalatex-site-Styles-highlightMe">List&lt;String&gt; ls = new ArrayList&lt;&gt;();</code></pre>
          <p>
            Here the compiler it self realizes that the object is of type <code>ArrayList&lt;String&gt;</code>. Some other examples:</p>
          <pre><code class="scala scalatex-site-Styles-highlightMe">List&lt;String&gt; ls = Collections.emptyList();
//compiler infers `Collections.emptyList()` to `Collections.&lt;String&gt;emptyList()`
Collections.max(Arrays.asList(1,2,3),(x,y) -&gt; Integer.compare(x,y));
//compiler infers the lambda to Comparator&lt;Integer&gt;</code></pre>
          <p>
            Many functional languages go very far to infer types. Even to an extent that you do not specify types anywhere in your program.
            Interested people should have a look at <a href="http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Hindley-Miler Type System</a>. It has been extremely influentional in type system of
            ML, OCaml, Haskell, F# etc.</p></div></hr>
<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="References" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">References<a class=" scalatex-site-Styles-headerLink" href="#References" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div><div class=" scalatex-site-Styles-content">
    <p>
      <ul>
        <li>
          To get started: <a href="https://docs.oracle.com/javase/tutorial/java/generics/">https://docs.oracle.com/javase/tutorial/java/generics/</a></li>
        <li>
          When you are stuck: <a href="http://www.angelikalanger.com/GenericsFAQ/FAQSections/ProgrammingIdioms.html">http://www.angelikalanger.com/GenericsFAQ/FAQSections/ProgrammingIdioms.html</a></li>
        <li>
          For precise insights: <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html">https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html</a></li>
        <li>
          To know more on types: <a href="http://www.cis.upenn.edu/~bcpierce/tapl/">TAPL</a></li>
        <li>
          <a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html">http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html</a></li>
        <li>
          <a href="http://cr.openjdk.java.net/~jrose/values/values-0.html">http://cr.openjdk.java.net/~jrose/values/values-0.html</a></li>
        <li>
          <a href="http://cr.openjdk.java.net/~briangoetz/valhalla/specialization.html">http://cr.openjdk.java.net/~briangoetz/valhalla/specialization.html</a></li></ul></p>
    <hr />
</div>
  <footer>
    <div style="opacity: 0.6;font-style: oblique;">
      <p>
        This booklet has been generated using <a href="https://github.com/lihaoyi/Scalatex">Scalatex</a> developed by <a href="https://github.com/lihaoyi">Li Haoyi</a>. You might want to look at it. Its easier to setup than <a href="http://jekyllrb.com/">Jekyll</a> and certainly more expressive than Wordpress. And provides compile time <i>like</i> type safety.
</p></div></footer>
</div><script>
    scalatex.scrollspy.Controller().main(
      [{"value":"Polymorphism","children":[]},{"value":"Generics","children":[{"value":"Type Erasure","children":[]},{"value":"Reification","children":[]}]},{"value":"Sub-Typing (<:)","children":[{"value":"Liskov Substitution","children":[]}]},{"value":"Variance","children":[{"value":"Co-Variance","children":[]},{"value":"Contra-Variance","children":[]},{"value":"In-Variance","children":[]},{"value":"Wildcards (?)","children":[]}]},{"value":"Case-Studies","children":[{"value":"Co-Variant Arrays","children":[]},{"value":"Writes & Reads","children":[{"value":"Writes","children":[]},{"value":"Reads","children":[]}]},{"value":"Library Examples","children":[{"value":"ArrayList","children":[{"value":"foreach","children":[]},{"value":"addAll","children":[]}]},{"value":"Collections.min","children":[]},{"value":"Collections.copy","children":[]},{"value":"Object.getClass","children":[]}]},{"value":"Function","children":[]}]},{"value":"More Interesting Stuff","children":[{"value":"Capture Type","children":[{"value":"New Instance","children":[]}]},{"value":"Java Type-System","children":[{"value":"Nominal Typing","children":[]},{"value":"Static & Strong","children":[{"value":"Type Inference","children":[]}]}]}]},{"value":"References","children":[]}]
  )</script><script>
    ['DOMContentLoaded', 'load'].forEach(function(ev){
      addEventListener(ev, function(){
        Array.prototype.forEach.call(
          document.getElementsByClassName('scalatex-site-Styles-highlightMe'),
          hljs.highlightBlock
        );
      })
    })
  </script></body></html>